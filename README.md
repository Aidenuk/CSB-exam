# CSB-exam 

due 25.05 

Week 01 software security 1 [컴퓨터 안에서 운용되는 프로그램,문서] <-> hardware [ 컴퓨터의 직접적인 성능에 관련된 부분 ( 마우스, 키보드, 모니터) ]


*security properties. (CIA)

1. confidentiality.(기밀성)
-> avoiding unauthorised disclousre of information. 

기밀성이란 특정 정보에 대해서 허가된 사용자 또는 대상에 대해서만 확인이 가능해야 한다. 
즉, 허가받지 않은 사용자 혹은 대상에 대해서는 접근이 되지 않아야 하며, 만약 접근이 된다면 해당 정보에 대해서는 기밀성이 깨졌다고 한다. 

2. intergrity.(무결성)
-> avoiding unauthorised modification of data.

무결성이란 특정 정보에 대해서 허가된 사용자 또는 대상에 대해서만 수정 및 삭제등 가능해야 한다. 
즉, 허가받지 않은 사용자 혹은 대상이 특정 정보에 대해서 수정 및 삭제가 되어야 하지 않아야 하며,만약 수정 및 삭제가 이뤄진다면 해당 정보에 대해서는 무결성이 깨졌다고 한다. 

3. availability.(가용성)
-> avoiding periods where authorised users can't use a system.

가용성이란 사용자 또는 대상에 대해서 특정 정보에 대한 접근 및 사용 필요시 항상 가능해야 한다. 즉, 원하는 시간,환경,서비스에 특정 정보를 사용할 수 있어야 하며, 만약 사용이 불가능 하면 해당 정보에 대해서는 가용성이 깨졌다고 한다. 


* Threat Modeling 

-> 사실 threat modeling 이라는 단어는 비단 IT에서만 쓰는 용어는 아니고, 위험 요소에 대해 평가해보는 전반에 걸쳐 사용되는 언어이다. 하지만 IT용어로써 Threat Modeling 이란 MS 사에서 대중화한 개념으로 잠재적인 위협을 모델링하고 이를 완화할 수 있도록 한 프로세스를 말한다. 

가령, 구조적 취약점이나 방화벽 등 보안장치의 부재와 같은 위협들이 모델링의 대상이 될 수 있다. 
위협 모델링의 목적은 시스템의 특성과 방어 시스템을 고려했을 때 어떤 부분에 있어서 방어가 필요하고 보안상 취약할 수 잇는지 가능성을 찾는 것으로 특히 특정한 위협포인트에 대해 미지수일 경우 가능한 취약점을 찾는 것이 되겠다. 또한, 공격자의 입장을 시뮬레이션 해보고 공격 측면을 찾아내는 일이 포함된다. 

그렇기 때문에 Threat Modeling 이 가능하려면 먼저 다음을 알아야 한다.
-시스템의 구조
-시스템의 보안 상태
-보호해야하는 가치있는 자산이 무엇인지
-가능한 공격자 후보군

*STRIDE

S : spoofing(공격자가 권한이 있는 사용자인척 위장하는 공격 방식)
T : Tampering(목적을 위해 시스템 내부 데이터를 악의적 수정해서 공격) 
R : Repudiation(악의적 활동 이후에 해당 활동에 대해 부인하는 것) 
I : Information Disclousre(보호된 정보에 대한 노출) 
D : Denail of Service(서비스에 대한 믿을 수 있는 접근을 바탕으로 한 공격. 분산해서 공격하는 것을 DDOS라 한다)
E : Elevation of Privilege


* Software Security Bugs

1. Integer overflow and underflow 
 
2. Buffer Overflow
 
3. Control flow corruption



**********************************************************************************************************************************************************

Week02 SoftWare Security 2

1. Memory Corruption (메모리부패)
-> 사용자가 부주의하여 명확한 할당 없이 주소에 접근하여 데이터를 변경하려 하거나 잘못된 주소 위치로 접근하려 할때. 
can lead to - arbitrary read/ write/ control flow hijack / corruption. 


* segmentation fault 
-> 잘못된 메모리 참조때문에 발생. 즉 건드리지 말아야 할곳을 건드렸기 때문에 발생. 

원인) 1. Null 값을 가르키는 포인터에 접근할 경우.
     2. 할당 받은 메모리 공간을 넘은 곳을 건드린 경우.
     3. 더 이상 존재하지 않는 메모리 영역을 가르킬 경우(Free)
     4. ready-only 표시 메모리 영역에 쓰려고 할 경우. 
     
     
********************************************************************************************************************************************************** 
 
 Week03 Cryptography. (암호화)
 
 This process converts the original representation of the information, known as plaintext into an alternative form known as ciphertext. 
 
 *symmentric key crytography (대칭키 암호화)
 
 공개키 / 개인키
 
 * 공개키 : 누구든지 키를 확인할 수 있고 사용할 수 있도록 대중에게 공개된 키를 의미한다.
 * 개인키 : 자기자신만이 관리하고 가지고 있는 키를 의미합니다. 

*대칭키 암호화 (secret key) 

-> 대칭키는 이름에서 알 수 있듯이, 어떤 정보를 암호화 복화화 할떄 사용하는 키가 동일한 경우. 
어떠한 정보가 대칭키를 통해 암호화 되었다면, 똑같은 키를 갖고 있는 사용자가 아니면 해당 정보를 확인 할 수 없다. 

따라서, 암호화된 정보를 전달하고 확인하기 위해서는 송,수신자 둘다 똑같은 키를 가지고 있어야 한다.

이러한 키를 안전하게 교환하는것이 대칭키 암호화 방식의 가장 중요한 부분이다 ! 이처럼 대칭키 암호화 방식은 키가 없다면 누구도 열어볼 수 없어 안전하지만, 이 키를 안전하게 전달하는것이 핵심

ex) 부산에 살고 있는 철수는 1번이라는 열쇠로만 열 수 있는 보물상자를 서울에 살고 있는 영희에게 보내려고한다. 그렇다면 철수는 영희에게 보물상자는 물론이고 1번이라는 열쇠를 같이 보내야지만
보물상자를 열 수 있다. 만약 보물상자와 함께 열쇠를 담아 보낸다면, 중간에 누군가가 가로채서 상자를 열어볼 수 있다. 따라서 이 열쇠는 보물상자와 다른 경로로 안전하게 전달 되어야한다. 


대칭키 암호화의 단점 -> 대칭키 암호화의 단점은 통신 네트워크 상의 맴버들의 수가 증가할 수록 필요한 키의 수는 제곱에 비례해 보안성을 위한 키 관리를 매우 어렵게 만든다. 
공개키 암호화에선 공개키는 다른 사람에게 알려져도 되지만, 공개키와 동시에 비밀스럽게 생선된 개인키는 반드시 비밀로 남아있어야 한다. 





*비대칭키 암호화 

-> 비대칭키 또한 이름에서 알 수 있듯이, 어떠한 정보를 암호화 복호화 할때 사용하는 키가 서로 다른경우를 의미한다. 
대칭키와 다르게 비대칭키를 활용한 암호화에는 개인키와 공개키 두가지가 사용된다.

또한, 비대칭키를 활용한 암호화는 개인키로 암호화를 하는 방식과 공개키로 암호를 하는 방식 두가지로 나눈다. 

1) 공개키로 정보를 암호화하는 경우
-> 공개키는 누가나 알 수 있도록 공개된 키이므로, 어떠한 정보를 특정 사용자에게 보낼 때 해당 사용자의 공개키를 통해 정보를 암호화하여 전송한다. 

ex) 부산에 살고 있는 철수는 서울에 살고있는 영희에게 보물상자를 보내려고 한다. 이때 A는 B의 공개키를 이용해 암호화를 하고 B는 이 보물상자를 열기위해서 B의 개인키가 필요하다. 
(공개키로 해제불가)

[ 철수는 영희의 공개키를 이용해서 암호화 하고 보물상자를 받은 영희는 본인의 공개키롤 암호화가 되어 있기 때문에 본인의 개인키로 열람가능]



2) 개인키로 정보를 암호화하는 경우
-> 개인키는 자신만이 가지고 있는 키이므로, 어떠한 정보를 특정 사용자에게 보낼때 자기자신의 개인키를 통해 정보를 암호화하여 전송한다. 

Ex) 부산에 살고 있는 철수는 자기만의 개인키를 통해 보물상자를 암호화하여 영희에게 보낸다. 이 보물상자는 철수의 개인키로 암호화 되어 있기 때문에 철수의 공개키가 있어야만 열수있다.
하지만 철수의 공개키는 누구에게나 공개되어 있다. 따라서 영희는 보물상자를 받은 후 철수의 공개키를 이용해서 보물상자를 열 수 있다.

그럼? 철수의 공개키는 누구에게나 열려있으니깐 중간에 아무개가 가로채서 상자를 열어볼 수 있지 않을까? 

개인키로 정보를 암호화 하는 방법은 보물상자 안에 무엇이 들어있다기 보다는 누가 그 보물상자를 보냈는지가 중요하다. 

그러므로 이 보물상자는 철수의 공개키로만 열람할 수 있으므로 철수가 보낸 것이 확실하다는 증거 


* MAC (message authentication code) 메세지 인증 코드[블록 암호]
-> 메세지를 보냈을 때 보낸 사람으로부터 메세지가 변조되지 않았는지 여부 판단 가능 (무결성: 메세지 변조 여부 / 신뢰성 보장: 보낸 사람이 올바른지 여부 판단)

밥 / 앨리스 통신 

밥과 앨리스는 서로 사전에 대칭키 암호화 방식과 동일하게 키를 공유했다고 가정하자. 
밥은 메세지를 보낼 때 사전에 공유된 키를 이용해 MAC 알고리즘을 계산한다 ( 메세지를 전송할 때 뒤에 붙혀 전송)

앨리스는 해당 메세지와 공유된 키를 이용해서 MAC 알고리즘을 계산후 밥이 보낸 알고리즘과 일치하면 Valid. 

MAC / Hash 차이점 
-> Mac 의 기능은 암호학적 해쉬 가능과 매우 유사하지만, 해쉬의 경우 무결성이나 인증 자체를 제공하지 않는다. 중간자 공격의 영향에 취약하기 때문에 단순히 해쉬값을 Mac값 처럼 사용하면 중간에 
해커가 가로채서 자신의 메세지와 메세지에 대한 해쉬값을 보내면 알아차릴 수 없다. 

MAC / 전자서명 차이점
-> Mac의 경우 서명과 검증이 가능하지만 전자서명은 다르다. 동일 키를 사용하기 때문에 둘만의 통신에서 한명이 메세지를 보내지 않았다고 부인(Repudiation)을 하면 그것에 대한 증명이 불가하다.
(네트워크 전체 공유 비밀키의 경우도 마찬가지) 

반면, 전자서명의 경우 개인 키를 사용해서 서명이 되기 때문에 부인방지 가능 그러나, Mac 키에 사용자 정보를 바인딩하는 시스템에 의해서 부인방지 기능이 제공될 수 있다. 

동일한 키는 두사람이 소유하지만, 하나는 Mac생성에 사용할 수 있는 키, 다른 하나는 Mac 서명용으로만 허용하는 하드웨어 모듈에 두면 다른 키를 사용하므로 부인방지 기능을 제공할 수 있다.(금융권)

* 디피 헬만 키 교환 

-> 비대칭 알고리즘 사용 방식이고 상대방의 공개키와 나의 비밀키를 이용해서 비밀키를 생성.

ex) 철수의 공개키 & 영희의 비밀키를 DH연산을 통해서 영희의 비밀키를 만든다. 
    영희의 공개키 & 철수의 비밀키를 DH연산을 통해서 철수의 비밀키를 만든다. 
    
    즉 철수와 영희의 비밀키는 같아짐. 
    
********************************************************************************************************************************************************

*Week03 Web security 


* CSRF(Cross Site Request Forgery) 
인터넷 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 특정 웹사이트에 요청하게 만드는 공격 => 서버를 공격 

* XSS (Cross Site Scripting) [Reflective / Stored(Persistant] 
해커가 웹사이트에 악성 스크립트를 등록 -> 웹서비스는 이를 DB에 저장 -> User는 이 악성스크립트를 읽음 -> 악성 스크립트가 User Pc에서 실행 => 유저를 공격 

1) Reflective : 보통 URL 파라미터 특히 get방식에 스크립트를 넣어 서버에 저장하지 않고 즉시 스크립트를 만듬 공격자는 스크립트 삽입시 실행이 되는 취약점이 존재하는 페이지를 미리 탐색한 후 XSS공격을 위한 스크립트가 포함된 URL을 공격 대상자에게 노출 시키는 방법으로 수행. (유저) 

2) Stored / Persistant : 웹사이트의 게시판이나 댓글, 닉네임등 스크립트가 서버에 저장되어 실행되는 방식
공격자는 게시판에 스크립트를 삽입한 후 공격 대상자가 해당 게시글을 클릭 하도록 유도 

3) 두 공격의 차이점 : reflective (attacker has to find individual vicitims and send her/him the malicious link)
                  stored (All attacker has to do is to just poison the server. 
                  
                  
********************************************************************************************************************************************************                 

*Week04 Network Security





********************************************************************************************************************************************************
*Week05 OS System

*Os system -> 컴퓨터 시스템을 효울적으로 관리하며 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임.

1) 유저 모드 
유저가 접근할 수 있는 영역을 제한적으로 두고 프로그램의 자원에 함부로 침범하지 못하는 모드 이다.
우리는 여기서 코드를 작성하고 프로세스를 실행하는 등의 행동을 할 수 있다.
간단하게 유저 어플리케이션 코드가 유저모드에서 실행된다.



2) 커널 모드 

모든자원(드라이버, 메모리 ,CPU) 에 접근, 명령을 할 수 있다.
유저모드와는 비교가 안되게 컴퓨터 내부에 모든것을 다 접근하고 관리할 수 있다.


*커널 모드 동기화

커널모드에서 동작하는 동기화 기법을 커널모드 동기화 기법이라고 한다. 커널모드 동기화는 유저모드 동기화에 비하면 느리다. 유저모드에서 커널모드로, 커널모드에서 유저모드로의 전환이 필요하기 때문이다. 그러나 커널모드 동기화 기법에서는 유저모드 동기화가 제공해주지 못하는 기능을 제공받을 수 있다. 



Privilege level (특권 레벨)

특권레벨이란 어떤 시점에서의 CPU 권한 상태를 나타낸다. 특권 레벨에 따라 CPU가 현재 어떠한 명령을 실행 시킬수 있고 메모리의 어떤 범위에 접근할 수 있는지를 결정한다. 
CPU의 현재 특권 레벨을 CPL (current privilege level) 또는 동작레벨이라 한다. 

특권 레벨은 0 에서부터 시작하고 CPU와 운영체제에 따라서 레벨을 정한다. 레벨 숫자가 높을 수록(레벨3) 권한이 적고 레벨 숫자가 낮을 수록(0) 권한이 많다. 레벨이 높은 쪽에서 낮은 쪽의 권한을 넘보면 이를
문제 있는 행동으로 간주해서 운영체제는 그 실행을 막거나 아예 프로그램을 다운시켜버리기도 한다.

Intel x86 프로세서에는 레벨0과 레벨3 곧 Ring0 (kernel mode) 와 Ring3 (User mode) 만을 쓰고 있다. 커널 모드는 주로 디바이스 드라이버와 시스템에 직접 붙는 프로그램에서 쓰이며 저수준의 명령을 사용할 수 있다. 통상적으로 CPU는 특권 레벨 0 에서 운영체제를 실행하고 특권 레벨 3에서 응용프로그램을 실행 시킨다. 

특권 레벨에 따라 실행 시킬 수 있는 명령어가 다른데 예를 들어 CPU의 동작 정지를 가능하게 하는 HLT(종료) 명령은 CPU가 특권 레벨 0 인 상태에서만 실행이 가능하다. 만일 그외의 권한에서 실행을 할 경우 예외를 발생 시킨다. 이처럼 특권 레벨이 0이 아닌 실행 되지 않는 명령을 특권 명령이라고 한다. 

명령어 뿌만 아니라 메모리 영역도 특권 레벨에 따라 접근할 수 있는 부분이 다르다. CPU는 4GB의 주소공간 (x86 process)을 세그먼트로 분할 해서 관리할 수 있다. 각각의 세그먼트에는 세그먼트에 접글할 수 있는 CPU의 특권 레벨을 정하는 디스크립터 특권 레벨(DPL)을 설정할 수 있다. DPL은 곧 CPU의 특권 레벨과 대응 되기 때문에 0~3의 값을 가진다. 

Cpu는 현재 자신의 특권 레벨 이하의 DPL을 가진 세그먼트를 읽어올 수 없으며 이는 곧 특권 레벨 0에서 동작하는 운영체제는 어플리케이션의 메모리의 접근할 수 있지만, 특권 레벨3 에서 동작하는 어플리케이션은 그 이하의 DPL값을 가지고 있는 운영체제의 메모리 영역에 접근할 수 없음을 의미한다. 단 프로그램의 실행은 DPL과 CPL이 일치 할 때만 가능하다. 
설령 Ring0 인 운영체제라도 DPL이 3인 메모리 영역에 올라가 있는 프로그램을 실행할 순 없다. 



*스핀락 

만약 다른 스레드가 락을 소유하고 있다면 그 락이 반환될 때까지 계속 확인하며 기다리는 것. 
조금만 기다리면 바로 쓸 수 있는데 굳이 문맥교환으로 부하를 줄 필요가 있나? 라는 컨셉으로 개발된 것으로 임계구역에 진입이 불가능할때 문맥교환을 하지 않고 잠시 루프를 돌면서 재시도를 하는 것을 말함.
Lock-Unlock 과정이 아주 짧아서 락하는 경우가 드문 경우 유용하다. (= 적절하게 임계구역을 사용한 경우)

예를들어 단순히 어떤 숫자를 +1 을 해주는데 사용될 락이 있다고 해보자. 이 경우는 거창하게 문맥교환을 하면서 구현할 필요가 없다. 잠깐 밖에서 검사해보고 내가 사용가능하면 바로 처리 가능하도록 하는게 효율적

그냥 단순히 적절한 시간동안 외부에서 for / while loop 를 돌면서 락을 검사하고 처리하게 되는 것이다. 이 때 임계구역은 굉장히 작거나 아주 빨리 처리가 가능할 경우 이런 락을 쓴다. 

특성)

락을 얻을 수 없다면 계속해서 루프를 돌면서 확인한다. 이른바 바쁘게 기다리는 busy waiting 이다. 
바쁘게 기다린다는 것은 무한 루프를 돌면서 최대한 다른 스레드에게 cpu를 양보하지 않는 것이다. 
락이 곧 가능해질 경우 문맥교환을 줄여 cpu부담을 줄여준다. 
하지만 어떤 스레드가 락을 오랫동안 유지한다면 오히려 cpu 시간을 많이 소모할 가능성이 있다. 

하나의 cpu나 하나의 코어만 있는 경우에는 유용하지 않다. (중요!)
그 이유는 만약 다른 스레드가 락을 가지고 있고 그 스레드가 락을 풀어 주려면 싱글 cpu사용률 100%를 만드는 상황이 발생하므로 주의해야 한다. 
스핀락은 기본적으로 무한 for루프를 돌면서 락을 기다리므로 하나의 스레드가 락을 오랫동안 가지고 있다면 다른 blocking 된 스레드는 busy waiting을 하므로 cpu를 쓸데없이 낭비하게 된다. 

장점)

장점은 스핀락을 잘 사용하면 문맥교환을 줄여 효율을 높일 수 있다. 무한 루프를 돌기 보다는 일정 시간 락을 얻을 수 없다면 잠시 sleep하는 back off 알고리즘을 사용하는 것이 훨씬 좋다.(뮤텍스)


*세마포어

ex) 한 서버에 프린트가 5대가 있다고 가정해보자. 사용자가 프린트를 사용하려고 서버에 요청한다. 그러면 공유자원 즉 프린트가 5개가 있으니깐 5로 설정이 되고 그리고 프린터를 사용자가 사용할 때 마다 하나씩 감소한다. 그러다가 사용할 프린트가 없어지면 세마포어는 0 이 되고 누군가 프린터를 다 쓰고 반환하면 세마포어가 다시 1이 증가한다. 세마포어는 단순히 변수이다. 공유자원의 개수를 나타내는 변수.

그러면 자원을 어떻게 사용하고 반납하나? -> wait() / signal()

즉 사용하면 -1 반납하면 +1. 다만 세마포어 자체가 공유자원이 안되니깐 쪼개지지 않는 함수로 구성된다. shared data 를 보호하려고 세마포어를 사용하는데 세마포어 자체가 shared data 가 되면 말이 안됨.

shared data를 사용하려고 봤는데 shared data가 없으면 그럼 기다려야 하니깐 이 함수의 이름을 wait이라고 지었고, 지금 비어있는 shared data가 있다 그러면 안기다리고 바로 사용(-1)
그런데 만약 shared datar가 0 이면 남은게 하나도 없다는 뜻이니깐 기다려야 한다고해서 wait이다.


다 쓰고 나서는 세마포어 값을 +1 시켜주면 된다 내가 다 쓴 이 shared data를 누군구가 기다릴 수 있다. 그래서 그 기다릴 사람에게 신호를 보내줘야 하므로 이름이 signal.


[wait]
<img width="855" alt="Screenshot 2022-05-22 at 14 50 30" src="https://user-images.githubusercontent.com/84698855/169698420-4e89361c-bce2-46f4-b370-95de05cf48bb.png">

[signal]
<img width="862" alt="Screenshot 2022-05-22 at 14 50 52" src="https://user-images.githubusercontent.com/84698855/169698437-a4210186-b58e-46ee-9994-0685fbd58a56.png">



********************************************************************************************************************************************************

*Week07 Scheduling 

*Cpu 스케쥴러 -> 다중 프로그램 os 기본으로, 여러 프로세스들이 cpu를 교환하여 보다 생산적으로 동작.
cpu를 선정한 프로세스가 대기하는 시간을 보다 효율적으로 사용하기 위해서. 

일반적인 시스템에서는 다음과 같은 목적을 공통으로 지닌다. 
1) no starvation (굶주림현상) : 각각의 프로세스들이 오랜시간 동안 cpu를 할당받지 못하는 상황이 없도록 한다.
2) Fairness : 각각의 프로세스들이 공평하게 cpu를 할당.
3) Balance : Keeping all parts of the system busy.


* 비선점 스케쥴링 / 선점 스케쥴링 

비선점 : 이미 할당된 자원을 다른 프로세스가 빼앗을 수 없는 방식. 
선점 : timeslice가 소진되었거나 I/O interupt, systemcall 이 발생되면 현 실행 프로세스로 부터 강제로 cpu를 회수하여 프로세스를 스위칭 하는 방식. 



(1) FCFS (First come Fitst served) [비선점 스케쥴링 Non- preemtive scheduling]
-> 먼저 cpu를 요청하는 프로세스를 먼저 처리하는 방식 (cpu를 요청하는 프로세스의 burst time 에 따라 평균 waiting time 이 bad)

(2) SJF (Shortest job first) [선점 스케쥴링 preemitive scheduling]
-> 평균 waiting time을 최소화 하기 위해 사용하는 방식 (burst time이 짧은 프로세스부터 CPU를 할당)

문제점) waiting time 을 최소화 하는데 최적이지만, burst time이 긴 프로세스는 오랜시간동안 굶주려야 하므로 no starvation 을 위반한다. 


(3) SRTF (Shortest remaining time first) 
-> 최단 잔여시간을 우선하는 스케쥴링 진행중인 프로세스가 있어도 최단잔여 시간인 프로세스를 위해 sleep시키고 짧은 프로세스를 먼저 할당. 

(4) RR (Roubine Round) 
-> Time sharing system을 위해 설계된 스케쥴링. 모든 프로세스가 같은 우선순위를 가지고 time-slice 기반으로 스케쥴링 time slice burst 가 일어나면 해당 프로세스는 스케쥴링 큐의 끝으로 이동

time-slice 가 큰 경우 : FCFS 와 비슷 
           가 작은 경우: 문맥교환이 많이 일어남 (비효율)
           
           
           
* 쓰레드_ yield -> 실행 중 우선순위 동일한 다른 스레드에게 실행을 양보하고 실행 대기 상태가 됨.

         
           
* MLFQ 기본 규칙 

-> 여러 개의 큐로 구성되며, 각각 다른 우선수위가 배정된다. 실행 준비가 된 프로세스는 이 중 하나의 큐에 존재한다. 실행할 프로세스를 결정하기 위하여 우선순위를 사용한다. 
높은 우선순위를 가진 작업, 즉 높은 우선순위 큐에 존재하는 작업이 선택된다. 큐에 둘 이상의 작업이 존재할 수 있다. 이들은 모두 같은 우선순위를 가진다. 이 작업들 사이에서는 라운드 로빈 스케쥴링 
알고리즘이 사용된다. 

MLFQ 스케쥴링 핵심은 우선순위를 정하는 방식이다. 각 작업에 고정된 우선순위를 부여하는 것이 아니라 각 작업의 특성에 따라 동적으로 우선순위를 부여한다. 

예를들어, 어떤 작업이 키보드 입력을 기다리며 반복적으로 CPU를 양보하면 MLFQ는 해당작업의 우선순위를 높게 유지한다. 
이러한 패턴은 대화형 프로세스가 나타내는 패턴과 같다. 대신에 한 작업이 긴 시간 동안 CPU를 집중적으로 사용하면 MLFQ는 해당 작업의 우선순위를 낮춘다. 이렇게 MLFQ는 작업이 진행되는 동안 해당
작업의 정보를 얻고, 이 정보를 이용하여 미래 행동을 예측한다. 


********************************************************************************************************************************************************
*Week08 Memory

가상메모리란? 
-> 메모리 관리 기법중 하나로 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법.
1. 사용자 프로그램이 물리 메모리의 제약에서 벗어남
2. 각 프로그램이 더작은 메모리를 차지하기 때문에 더 많은 프로그램이 동시에 수행 가능( 한것처럼 보임)
3. 프로그램을 메모리에 올리고 swap하는데 필요한 I/O 횟수가 줄어듬.



********************************************************************************************************************************************************
*Week09 OS security

*MAC [ Mandatory access controls ]
-> 미리 정해진 정책과 보안 등급에 의거하여 주체에게 허용된 접근 권한과 객체에게 부여된 허용등급을 비교하여 접근을 통제하는 모델.
높은 보안을 요구하는 정보는 낮은 보안 수준의 주체가 접근할 수 없으며 소유자라고 할지라도 정책에 어긋나면 접근할 수 없으므로 강력한 보안을 제공.

*DAC [ Discretionary Access Control ]
-> 접근 주체 신분기반 접근권한 부여.


<img width="461" alt="Screenshot 2022-05-24 at 11 57 46" src="https://user-images.githubusercontent.com/84698855/170019389-2ff348cc-7e6b-4ee1-9730-b3ec00ee100b.png">



* Segmentation 

먼저 어떤 프로세스에 대해 액세스해도 좋은 메모리 범위(세그먼트)를 정한다. 이는 해당 메모리의 시작 주소 크기 권한을 포함하고 있다. 이런 각 세그먼트에 관한 정보를 segment descriptor 라고 하며, 
이를 모아서 테이블로 만든 것을 descriptor table 이라고 한다. 

16비트 리얼 모드에서는 (세그먼트 레지스터 * 16 + 오프셋 주소) 로 실제 주소를 구했지만, 보호모드에서는 세그먼트 레이저스터에 씌여진 값이 바로 주소로 연결되는 것이 아닌 descriptor table에서의
오프셋을 의미한다. 


* segmentation & paging 차이점

메인 메모리 : cpu가 직접 접글할 수 있는 기억 장치로, 프로세스가 실행되려면 프로그램 코드를 메인 메모리에에 적재해 두어야 한다. 그런데 만약 프로그램 용량이 메인 메모리보다 크면 어떤 일이 벌어질까?


가상 메모리: 실제 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것이다. 메모리의 공간은 한정적이므로 사용자에게 더 많은 메모리를 제공하기 위해 가상 주소를 사용한다. 메모리 장치는 가상주소를 이용해 실제 데이터가 담겨 있는 주소로 변환해 준다.

여기서 가상주소 공간은 하나의 프로세스가 메모리에 저장되는 논리적인 모습을 가상 메모리에 구현한 공간이며, 가상주소는 해당 공간을 가리키는 주소이다. 

가상메모리가 필요한 이유? 

-> 물리 메모리의 한계  1) 모든 프로그램 코드를 물리 메모리에 올릴수 가 없다.
                   2) 그렇다고 프로그램을 교체하면서 올리면 메모리 교체 성능 문제가 발생.
                   
-> 가상 메모리의 장점 
1. 프로그램 용량이 실제 물리 메모리보다 커도 된다.
2. 전체 프로그램이 물리 메모리에 올라와 있지 않아도 된다.
3. 더 많은 프로그램을 동시에 실행할 수 있다.
4. 즉 다중 프로그래밍을 실현하기 위해 물리메모리의 제약을 보완하고 프로세스 전체를 메모리에 올리지 않고도 실행할 수 있도록 해줌.

* 주기억장치 & 보조기억장치 
 가상 메모리의 구현
 -> 운영 체제는 물리 메모리의 제약을 갖고 있는 주 기억 장치를 보조하기 위해 디스크를 보조 기억 장치로 사용
 
 즉, 메인 메모리와 디스크이 페이징 스페이스를 묶어 하나의 메모리처럼 동작하게 하며, 이를 통해 메인 메모리의 한계를 넘는 메모리를 사용을 가능하게 하는 가상 메모리를 구현
 
 
 * Swapping 

-> CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억 장치로 보내고 다른 프로세스의 메모리를 불러오는 작업을 스왑이라고 한다. 이러한 스왑 작업에는 디스크 전송 시간이 들기 떄문에 메모리 공간이 부족할 때 스와핑이 이루어 진다.

* 메모리관리

-> 다중 프로그래밍 시스템에 여러 프로세스를 수용하기 위해 주 기억 장치(RAM)을 동적 분할하는 메모리 관리 작업이 필요하다. 즉, 하드 디스크에 있는 프로그램을 어떻게 메인 메모리에 적재할 것인지 판단.

* 페이징

-> 프로세스를 일정한 크기의 페이지로 분할해서 메모리에 적재하는 방식이다. 

페이지: 고정 사이즈의 가상 메모리 내 프로세스 조각
프레임: 페이지 크기와 같은 주 기억 장치의 메모리 조각

하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법이다. 

*페이징 테이블 

-> 물리 메모리는 고정 크기의 프레임으로, 가상 메모리는 고정 크기의 페이지로 분리되어 있다. 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 매핑되어 저장된다.
즉, 모든 프로세스는 하나의 페이징 테이블을 가지고 있으며, 여기에는 메인 메모리에 적재되어 있는 페이지 번호와 해당 페이지가 위치한 메인메모리의 시작 주소가 있다. 
이를 통해 하나의 프로세스를 나눈 가상 메모리 페이지들이 각각 실제 메인 메모리의 어디 프레임에 적재되어 있는지 알아낼 수 있다. 


* 논리 주소와 페이지 테이블 

-> 앞서 메모리 관리장치 (MMU)는 가상주소(논리주소)를 이용해 실제 데이터가 담겨 있는 주소로 변한해준다고 했다. 
 
논리주소는 <페이지,오프셋> 과 같은 형태로 구성되는데, 이를 이용해 물리주소로 변환해주는 것이다. 



* 페이징의 장단점 

장점) 논리 메모리는 물리 메모리에 저장될 때 연속되어 저장될 필요가 없고, 물리 메모리의 남는 프레임에 적절히 배치되기 때문에 외부 단편화가 생기지 않는다.

단점) 내부 단편화 문제가 발생할 수 있다. 페이지 단위를 작게하면 해결할 수 있지만, 페이지 매핑과정이 복잡해져 오히려 비효율적이다.

* 세그먼트 테이블 

분할 방식을 제외하면, 페이징과 세그멘테이션이 동일하기 때문에 매핑테이블의 동작 방식도 동일하다. 다만, 논리주소와 앞 비트들은 페이징 번호가 아니라 세그먼트 번호가 될 것이다.
즉, <segment, offset> 형태로 구성되며, 세그먼트 번호를 통해 세그먼트의 기준(세그먼트의 시작 물리주소)와 한계(세그먼트의 길이)를 파악할 수 있다. 





